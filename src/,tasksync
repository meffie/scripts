#!/usr/bin/python3

import configparser
import os
import pprint
import re
import sh
import ssl
import sys

try:
    import kanboard
except ImportError:
    sys.stderr.write('kanboard module not found.\n')
    os.sys.exit(1)

try:
    import taskw
except ImportError:
    sys.stderr.write('taskw module not found.\n')
    os.sys.exit(1)

# Monkey patch ssl module to work around our malformed cert.
# Fixes the error:
#     ssl.CertificateError: hostname 'kb.devlab.sinenomine.net' doesn't match u'debian-8-x64-02'
ssl.match_hostname = lambda cert, hostname: True
ssl._create_default_https_context = ssl._create_unverified_context

class Config(object):

    def __init__(self, filename='~/.kbrc'):
        self._filename = os.path.expanduser(filename)
        if not os.path.exists(self._filename):
            raise OSError(2, f'Config file not found: {self._filename}')
        self._config = configparser.ConfigParser()
        if len(self._config.read(self._filename)) != 1:
            raise OSError(2, f'Unable to read config file: {self._filename}')

    @property
    def host(self):
        return self._config.get('kanboard', 'host')

    @property
    def token(self):
        return self._config.get('kanboard', 'token')

    @property
    def url(self):
        return os.path.join(self.host, 'jsonrpc.php')

    @property
    def project_id(self):
        return int(self._config.get('sync', 'project'))

    @property
    def username(self):
        return self._config.get('sync', 'username')


class Task(object):

    def __init__(self, data):
        self._data = data

    def __repr__(self) -> str:
        return pprint.pformat((self.kb, self.uuid, self.status))

    def done(self):
        print(f'done: task {self.uuid} {self.status}')

    @property
    def status(self):
        return self._data['status']

    @property
    def description(self):
        return self._data['description']

    @property
    def kb(self):
        return int(self._data['kb'])

    @property
    def uuid(self):
        return self._data['uuid']

    @property
    def tags(self):
        return self._data.get('tags', None) or []

    @property
    def project(self):
        return self._data.get('project', None) or ''


class Card(object):

    def __init__(self, data):
        self._data = data

    def __repr__(self) -> str:
        return pprint.pformat((self.id, self.column))

    def create_task(self):
        print(f'create a task for card {self.id}')

    @property
    def title(self):
        return self._data['title']

    @property
    def id(self):
        return int(self._data['id'])

    @property
    def swimlane(self):
        swimlane = self._data['swimlane_name'] or self._data['default_swimlane']
        return swimlane.replace(' ', '').lower()

    @property
    def column(self):
        return self._data['column_name'].replace(':', '').replace(' ', '-').lower()

def main():
    config = Config()
    tw = taskw.TaskWarrior()
    kb = kanboard.Client(config.url, 'jsonrpc', config.token)

    tasks = {}
    for data in tw.filter_tasks({'kb.isnt': ''}):
        task = Task(data)
        if task.kb in tasks:
            raise AssertionError(f'Duplicate task kb value {task.kb}.')
        tasks[task.kb] = task
    # pprint.pprint(Task.all)

    cards = {}
    query = f'status:open assignee:{config.username}'
    for data in kb.search_tasks(project_id=config.project_id, query=query):
        card = Card(data)
        if card.swimlane == "longterm":
            continue   # Skip backlog
        if card.column == "done":
            continue   # Card was moved to done column, but not closed yet.
        if card.id in cards:
            raise AssertionError(f'Duplicate card id value {card.id}.')
        cards[card.id] = card
    # pprint.pprint(cards)

    task_ids = set(tasks.keys())
    card_ids = set(cards.keys())

    # Cards without tasks.
    for id_ in card_ids - task_ids:
        cards[id_].create_task()

    # Tasks without cards.
    for id_ in task_ids - card_ids:
        task = tasks[id_]
        if task.status == 'pending':
            task.done()

    # Instersection.
    for id_ in task_ids & card_ids:
        task = tasks[id_]
        card = cards[id_]
        print(f'update {id_}')


def old():
    if True:
        if card['is_active'] == '1' and card['swimlane_name'] != 'Long Term' and card['column_name'] != 'Done':
            if task:
                if task['status'] == 'completed':
                    # taskw task_update() fails to actually modify the task, so
                    # so fallback to running 'task modify' directly.
                    uuid = task['uuid']
                    sh.task(uuid, 'modify', 'status:pending')
                    print(f'Updated task {uuid} for card {kb_id}.')
            else:
                # Import card
                # Extract project name from card title.
                m = re.match(r'([a-zA-Z0-9-]+):\s+(.*)', card['title'])
                if m:
                    project = m.group(1)
                    title = m.group(2)
                else:
                    project = None
                    title = card['title']
                # Filter out non-alphanum from title and keywords to avoid add failure.
                title = re.sub(r'[^a-zA-Z0-9 \-.]+', '_', title)
                title = title.replace('ticket', '_ticket').replace('gerrit', '_gerrit').replace('kb', '_kb')
                ticket = card['reference']
                fields = {'kb': int(kb_id)}
                if ticket:
                    fields['ticket'] = int(ticket)
                if project:
                    fields['project'] = project
                task = tw.task_add(title, **fields)
                uuid = task['uuid']
                print(f'Added task {uuid} for card {kb_id}.')
        elif card['is_active'] == '0' or card['column_name'] == 'Done':
            if task and task['status'] == 'pending':
                # Update task
                task['status'] = 'completed'
                uuid = task['uuid']
                sh.task(uuid, 'done')
                print(f'Completed task {uuid} for card {kb_id}.')


if __name__ == '__main__':
    main()
